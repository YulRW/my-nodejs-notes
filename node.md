# node

记笔记很重要！！（归类整理）

为什么学Node-->招聘上来讲：具有服务端开发经验更好



Node.js是js运行时环境--》可以解释并执行js代码--》可以用nodejs脱离浏览器来运行！。不是语言也不是库不是框架

1. nodejs里面包含

​	ecmascript（没有dom和bom）

**在node这个js环境中为js提供了一些服务器级别的操作api（可以控制服务器）

​	例如：文件读写

​	网络服务构建

​	网络通信

​	（所以主要做服务端这些事儿



解析js代码---->js引擎 （v8引擎），他是解析执行js代码的机器---是一个虚拟机

**nodejs的作者把v8引擎移植出来做了开发了独立的js运行环境





学nodejs----》学web服务器开发



2. node使用了（特性） 1. 事件驱动
   		2. 非阻塞IO模型（简单来讲就是异步操作）
     		3. 轻量和高效
3. npm是基于nodejs开发的包管理工具，是世界上最大的开源库生态系统（让开发人员更方便地下载和使用）





### nodejs能做什么？

web服务器后台（php ，java）

命令行工具（git（c），npm（node），hexo（node），在命令行下运行的工具----》用命令来开发）----》是辅助类工具

对于前段开发工程师来讲，接触node最多的是命令行工具，但是自己写的很少，主要是用别人的：webpack，gulp，npm，



要知道一些简单的命令行操作：cd（切换   dir（列出目录  ls（列出目录

mkdir rm 等





##### 一些资源：

深入浅出nodejs---》学node底层最好，，偏理论，几乎没有实战内容，纯底层，帮助理解原理，底层有帮助，需要一些基础。

nodejs权威指南--》api讲解，无业务无实战

学习是个过程--》要慢慢学，多几遍学习 

node入门——》推荐去看  nodebeginner.org

cnodejs 里面有很多不错的资源



##### 这门课学到了什么？



B/S变成模型（浏览器和服务器模型  browser-server  back-end 任何服务端技术这种BS编程模型都是一样的，和语言无关，即模型和概念是一样的

node只是作为我们学习BS编程模型的工具而已，技术只是工具

，只要能解决问题的都是好东西

模块化编程

- require js
- seajs
- @import（‘’）（js不行，以前js必须要通过html页面的标签才能使用
- 在node中可以像@import来引用加载js脚本文件

node常用的api



- 异步编程

- 回调函数（在node里面有很多很多0
  - promise
  - async
  - generator
- express web 开发框架
- es 6 （穿插讲解

##### 学习node不仅可以帮助大家打开服务端黑盒子，还可以帮助学习前端高级内容：vue react angular（有很大帮助！！！





## 2.起步

下载，安装  



执行代码：文件就是.js文件，没有html页面

如何运行js？

用命令工具行--》cd切换过去

或者：在目录那边，用gitbush就可以打开（用什么都行

或者：按住shift+右键也可以打开命令行窗口



1. 定位到相应的目录
2. node + 文件
3. 运行！这个时候已经脱离浏览器运行了



#### 01-没有bom和dom

log（document），log（window 

但是可以有：

- 读写文件（浏览器不能读某个文件的内容，不能生成文件写文件



#### 02-读取文件

//浏览器中的js是没有文件操作能力而node可以

--》buffer是二进制数据

文件中存储的其实是二进制01数据

但为什么看到不是01呢，是因为2转到16进制了。

我们可以通过toString转成字符

cls清屏 （clear



#### 07 简单的http服务 

node可以非常轻松的构建一个web 服务器 ，非常简单

在node中专门提供了一个核心模块：http

http这个模块的职责就是帮忙创建服务器的

tip：命令工具按上箭头可以快速用上一条  命令



服务器设置

服务器启动



服务器启动后不能再使用工具命令行，包括cd之类，以及一些其他操作，而且不能关闭

ctrl+c 关闭服务器  



所有请求路径都是以/开头



代码如果修改了一定要重启服务器才生效



遇到问题：response.write()写出的内容如果是中文那么会返回乱码

思考：请求不同的路径的时候响应不同的结果



现在可以根据发送请求的不同路径而返回字符串，但是还要学如何返回不同的html、json等





res.write()其实比较麻烦，一般很少会用。

推荐直接end的同时发送响应数据

res.end(“hello”)//发送响应数据的同时结束响应

注意，响应内容只能是二进制或者字符串，其他都不行（数字，对象，数组，布尔）



favicon.ico请求：浏览器标签请求



#### 先讲模块 08-

node中有：

- ecmascript
  - 没有dom bom
- 核心模块
- 第三方模块
- 用户自定义模块



##### 核心模块 

在node中为js提供了很多服务器级别的api，这些api很多都包装到了具名的核心模块中了

例如，文件操作的fs核心模块 http服务 的核心模块 path路径操作模块  os操作系统信息模块等等等等



以后只要说这个模块是核心模块，就要想到要使用就要引用

var fs = require('fs')

os:operation system



#### 模块化编程

引入js文件

require是一个方法，他的作用是用来加载模块的

在node中模块有三种

- 具名的核心模块

- 用户自己编写的文件模块（说白了就是js

  require引入时，相对路径必须加./或者../，不然就会被当做核心模块了，后缀名（.js）可以省略

require模型的执行顺序：执行引入的模块后再出来继续执行原有模块

node中没有全局作用域只有模块作用域

单个模块用不了外部文件的属性，外部文件也拿不到他的属性

##### 模块间如何通信？

有时候加载文件的目的不是为了简单地执行代码，更重要的是使用里面的某个成员



--加载与导出

require方法有两个作用，

- 加载文件模块并执行代码
- 拿到被加载文件模块导出的接口对象

每个文件模块（js）都提供了一个exports对象（使require有返回值

exports默认是空对象

我们要做的是把所有对象成员挂载到exports成员对象中

exports.foo = "hello world"



#### ip地址和端口号

计算机只有一个物理网卡

同一个局域网中网卡的地址必须是唯一的

网卡是通过唯一的ip地址来进行定位的

所有需要联网的软件都要网络通信，

服务器可能有多个需要网络通信的软件，所以当其他客户端发送请求时需要知道这个请求对应的是服务器哪个通信软件，所以用端口号来判别



所以：ip地址用来定位计算机

端口号用来定位具体的应用程序

--》所有需要联网通信的软件都必须具有端口号



需要注意的是：响应回去的数据也必须要端口号

在服务器可以通过request.socket.remotePort来拿到客户端的端口号

我们的API已经高度封装，不需要知道IP地址和端口号，只需要发送响应就可以了

（实际上服务器也需要知道客户端的IP地址和端口号才能发送回数据）

客户端的浏览器会自动开一个端口号进行通信

什么时候用80端口？网站部署上线时用80，这样用户就不用手动输入端口号了（浏览器默认加80）



##### 总结

request

端口号

模块



一个项目需要依赖n多文件构成

可以同时开启多个服务，但其端口号不能一样（同一时间不能被同一程序占用

中文乱码问题

---》其实不是中文乱码的问题，是在服务器默认发送的数据，其实是utf8编码的内容

但是浏览器不知道你是utf8编码的内容 

浏览器在不知道服务器响应内容的编码的情况下会按照当前操作系统的默认编码去解析

中文操作系统默认是gdk，所以解析不正确--》乱码

所以要告诉浏览器发送的是utf8

不同类型的content-type 



如何通过一个地址访问html？？？

以前--》通过把html扔进apache然后设置默认打开页面

现在node：要创建apache（因为没有apache的能力）



读文件返回的data默认是二进制文件，可以通过toString转为咱们能识别的字符串

图片就不需要指定编码了，一般常说的编码指的是字符编码，所以把charset=utf-8去掉



url：统一资源定位符---》url最终是定位到一个资源的



总结：结合fs发送文件数据

Content-Type不一样

学习:如何在项目中使用这种变成方式



核心模块是由node提供的一个个具名的模块,他们都有自己特殊的名称标识

什么是require,端口号



之后讲: node中的其他核心模块,

做一个小管理系统:增删改查CRUD

学Express Web 开发框架(可以把通过手动设置路径来访问资源而变得极其简单)



一切先教你框架的都是耍流氓



## day2

要学的:request  response

node中使用模板引擎(最早期是用在服务端)

统一处理静态资源(之前所有资源访问都要ifelse判断....)

服务端渲染

做留言本



提问:

md使用风格:由git推荐使用的"GFM"风格



#### 代码风格



一些代码风格定义:

- javascript standard style
- airbnb javascript style(更加严谨)

通过看别人的代码风格可以很容易知道是新手还是老手

当采用无代码风格时,要注意以下三种情况:

- 当一行代码是以 ( [ `开头的时候,则在前面补上一个; 避免一些错误(反引号是es6新增的字符串包裹方式,叫模板字符串,他支持换行和方便的拼接变量,普通字符串不支持换行的,可以理解为html的pre标签),

无论是有分号还是无分号的风格,一行代码如果是以([`开头的,都建议加上分号



有时候不一定要是分号,也可以加!或者~等奇奇怪怪的符号...



##### 服务器开发

永远是请求/响应

一个请求对应一个响应,如果在请求过程中已经结束响应了,则不能重复发响应

而且没有请求就没有响应

apache软件有个www目录,所有存放在www的都可以通过地址来访问到

return有两个作用:

- 阻止代码继续执行(return res.end('404'))
- 方法返回值

c除了Content-Type 可以指定编码以外,浏览器也可以通过meta标签元数据来声明当前文本的编码格式,浏览器也会识别它(一般描述特征/信息/存储内容的叫元数据)



模仿apache:

- 可以通过url来直接访问目录下的任意资源(通过拼接ip+url来实现)
- 在访问目录时可以显示目录列表



->引出需求:

- 如何将目录的下的文件名全部获取-->fs.readdir

- 如何将文件名替换到html中的指定位置---->模板引擎-->字符串解析替换
  - fs.readFile读取文件并获取html
  - 用data.tostring转换成字符串
  - 用data.replace('@@@','替换的字符串')来替换事先写的占位符



在服务端也可以使用模板引擎

##### 05-使用模板引擎

模板引擎有很多,太多了

常用:art-template不仅可以在浏览器使用,也可以在node中用

她是js模板引擎

npm install art-template -->最简单的安装方式



安装了art-template以后发现node_modules很多东西,因为AT还有一些别的依赖,它本身就是一个包,这个包还依赖于别的包



npm install art-template--->该命令在哪儿执行就会把包下载到哪里,默认会下载到node_modules目录里面,目录不可变.



- art-template教程

模板引擎最早是诞生于服务器,后来才发展到了前端



如何在服务端使用at?

- 下载安装 (用npm)
- 在要使用的文件模块中加载 at
- 查文档,使用模板引擎的api

!引入的模块不需要写什么相对路劲绝对路径,只要写模块名就OK,像加载核心模块那样子



用服务端的模板引擎来渲染叫做 服务端渲染



总结:

- 代码风格
  - javascript standard style
  - airbnb javascript style
- 分号的问题
  - 括号
  - 中括号
  - 反引号
  -   在以上的前面补分号
- 推荐书籍: 《编写可维护的javascript》
  - 不仅是功能,漂亮也是目标
- 在服务端使用模板引擎



服务端和客户端渲染的区别



浏览器:

- 第一次请求拿到的是页面的字符串,针对页面
- 第二次请求是在解析字符串时拿到的动态数据(ajax请求模板),针对接口数据

网站的loading是表示在正在请求

好处:页面显示比较快,但是内容数据就比较慢了



服务端渲染:

一次请求就搞定

- 请求页面------>服务器在那边就处理了,提前渲染好了再返回
- 只用请求一次



==>服务端渲染更快,但是服务端压力更大



客户端好处:能尽早看到页面

而服务端渲染他出来的就是结果了.



如果在源代码中看到了数据内容---->一定是服务端渲染过来的

而如果是客户端渲染,而查看不到数据



京东评价:评价按下一页时没有刷新,一看就是异步的.客服端渲染



商品列表下一页--->刷新了,一定是服务端渲染的



商品列表那么慢,为什么不用异步的?

原因:绝大数网站既有服务端也有客户端渲染

因为考虑SEO问题.----->ajax渲染的数据(异步数据),爬虫爬不到的

- 客户端渲染不利于SEO--->搜索引擎优化,可能就搜不到商品了
- 服务端渲染是可以被爬虫抓取,而客户端渲染很难抓取到
- 所以真正的网站既不是纯异步也不是纯服务端

所以商品列表用服务端渲染是为了SEO搜索引擎优化

而他的商品评论列表为了用户体验,而且也不需要SEO优化,所以用客户端渲染

如果以后爬虫可以抓取到异步的内容,那么可能以后所有网站都是异步的了..

异步体验好,而且开发方式简单

但是其实他里面东西还很多,目前只知道什么时候用客户端渲染什么时候用服务端渲染



以后的社区系统案例会给大家讲



Apache的那种文件列表的基础功能,其实是他本身那个软件已经帮你实现了,他后面的本质也是一坨代码



##### 开始做留言本 



习惯:把所有需要使用的包放在最前面

 简写:

http.createServer(function(req,res){

​	

})

自动把这个函数作为他request事件的函数---简写方式

http.createServer的返回值是server.

所以也可以直接

http.createSever().listen('8080',function...)



推荐文件放在 views中



当你需要操作字符串的时候才用转化成字符串

当返回的文件中里面又有其他文件请求(例如css

因为:.浏览器收到响应后会从上到下解析,若发现了link script img iframe video audio等具有src或者href属性的时候,浏览器会自动对这些静态资源发起新的请求

 页面本身是一个请求,而且页面里面的每一个资源也是请求



-->为了方便地统一处理这些静态资源,所以我们约定所有静态资源存放在public目录中

这样可以好处理,统一处理

可以判断页面请求访问的路径,当为/public/时当做静态资源处理: fs.readfile...然后文件..这样就相当于把public里面的文件开放出去了

如果以 / 开头则是在磁盘根目录开始,以./才是以当前目录开始

   

哪些文件能被通过目录访问哪些不可以,现在就可以对代码进行灵活的控制

而apache很难做到

真正网站有公共的也有非公共的文件



所以!只能通过/来这么做。所有服务端技术都是这么干的

现在变成了url路径-->以后所有的东西都用url地址!

以后开发就是这么干的



当你到了前后端融会贯通了以后,就有那种感觉:为所欲为!!!!!!!!!!!!!!



### 领悟

领悟: 用户访问的url的名字不一定就是返回文件的名字,开发者可以根据用户输入了什么(url),来返回任何自己想返回的东西---->url只是一个标识,而/只不过是方便去分类??而后台想要发送什么样的文件,确实需要/路径来查找自己想返回的文件

前端里面输入的url 或者是点击a标签,实际上是发送了一个请求,请求内容是url:xxx,这个请求是任意的,但是必须要和后台协商好

url相当于请求,而且还可以附带参数,相加自己想加的参数,后台可以从中解析,其实不一定要?key=value&key=value,只不过form表单提交是默认的,我们后台要从中手动拿取





去掉后缀名:美化url--->精简





##### 渲染

 template.render(data.toString(),{

​	comments:comments

})



##### 表单提交:

- 表单中要提交的必须有name属性
- 表单提交分为:
  - 默认的提交行为--->代码不用写,默认发送
  - 异步提交:我们需要自己写一些代码
- action是表单提交的地址-->说白了就是请求提交的地址
- method请求方法



有个核心模块名叫url 里面有个parse()方法



url.parse(url)--->可以变成对象,把url拆成多个部分

可以在返回的对象里面  query获取

pathname就可以获得不包含字符串的路径

url.parse(url,true)-->

获取的对象返回时,query也是一个对象了,里面有url的参数对象



结论:对于我们来说只要判定请求路径是/pinglun时,就认为提交表单的请求过来了



疑问: 每次 url.query的时候会有 **[Object: null prototype]**,导致不能点出query

****URL接口废弃



技术只是工具,领起来就干!解决问题

现在只是见得少

需要一个过程去适应

服务器原来是傻子-------->现在可以解决问题了

服务端都是通用的!API不一样但是道理都一样



获取完问询参数后

---->可以重定向

如何通过服务器让客户端重定向?

- 状态码设置为302----临时重定向  (还有永久重定向)
- 响应头中通过location告诉客户端(往哪里重定向?)

如果客户端收到服务器的响应的状态码是302,就会自动去响应头去找location ,然后对该地址发出新的请求

所以能看到客户端自动跳转了

res.statusCode = 302;

res.setHeader('location','/')





node从0.12.7 直接到4.0.0

react 直接从 0.xx直接蹦到14.xx 版本帝

笑死我了

